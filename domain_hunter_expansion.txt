<document>
# Brand Package Generator - Complete Product & Technical Specification
Product Overview
Name: Brand Package Generator
Tagline: Complete startup brand identities in 5 minutes for $29
Target Market: Pre-launch startups, solo founders, side project entrepreneurs
Problem Statement
Early-stage founders waste 4-8 hours and $30-95+ jumping between multiple tools (Namelix, Looka, GoDaddy, Coolors) to create basic branding.
Solution
All-in-one brand package generator delivering complete brand identities instantly:

Business name suggestions with domain availability
Logo designs (3 variations)
Color palettes (5-6 colors with hex codes)
Taglines (5 variations)
Domain checking
Downloadable assets (PNG, JPG, SVG)
Brand history dashboard

Competitive Advantage

All-in-One - First tool packaging everything together
Speed - 5 minutes vs 4-8 hours DIY
Price - $29 vs $30-95 fragmented or $3,800+ agencies
Modular - Users can generate specific components independently
AI-Powered - Pattern-based generation using proven success frameworks


User Journey & Features
Phase 1: Input (Universal)
What user provides:

Business description (required) - detailed text field covering concept, target audience, style preferences
Business name (optional) - if user already has one
Industry selection (optional)
Style preference (optional) - modern, playful, elegant, bold

Key insight: Description is universal input for ALL services. LLMs extract what they need from it.
Phase 2: Modular Generation
User can choose any sequence or skip phases:
A. Name Generation (optional)

Input: Description
Output: 10 brandable name suggestions
User selects one OR provides their own

B. Domain Checking

Input: Selected name(s)
Output: Availability status, pricing, purchase links
Integration: Affiliate commissions from registrars

C. Logo Generation (requires name)

Input: Description + name
Output: 3 logo concepts with variations
Formats: PNG, JPG, SVG
LLM validates name exists or prompts user

D. Color Palette Generation

Input: Description + name + optional logo reference
Output: 3-5 color palettes with hex codes
Industry-appropriate combinations

E. Tagline Generation (requires name)

Input: Description + name
Output: 5 tagline variations
Context-aware, industry-specific tone

Phase 3: Review & Iterate

User reviews generated options
Can regenerate any component with feedback
Mix and match preferred elements
Save to project history

Phase 4: Export & Download

Download selected assets (images, color codes, taglines)
PDF brand guidelines (future)
View in dashboard history
Copyright assigned to user


Technical Architecture
Tech Stack
Frontend

React.js (existing)
Supabase JS Client (auth + database)
Axios/Fetch for API calls

Backend

FastAPI (Python)
Async/await for concurrent operations
Pydantic for request/response validation

Database & Storage

Supabase Postgres (relational data)
Supabase Auth (Google OAuth)
Supabase Storage (generated assets)

External APIs

OpenRouter (Claude, GPT-4, Gemini)
Image APIs: Flux, Ideogram, Stability AI (failover)
Domain checking: DNS + WhoisXML/WhoAPI

Deployment

Railway or Render (backend hosting)
Vercel (frontend hosting)
Supabase Cloud (managed)


Backend Architecture
Directory Structure
/backend/
  main.py                           # FastAPI application entry
  
  /core/
    ai_manager.py                   # Unified AI operations manager
    research_loader.py              # Load & cache intelligence patterns
    failover_manager.py             # Image API failover logic
    
  /services/
    name_service.py                 # Business name generation
    domain_service.py               # Domain availability checking
    logo_service.py                 # Logo concept generation
    color_service.py                # Color palette generation
    tagline_service.py              # Tagline generation
    
  /database/
    client.py                       # Supabase client initialization
    models.py                       # SQLAlchemy/Pydantic models
    repositories.py                 # Database operation abstractions
    
  /middleware/
    auth.py                         # JWT token validation
    rate_limiter.py                 # Usage limits per user
    error_handler.py                # Centralized error handling
    
  /api/
    routes.py                       # API endpoint definitions
    schemas.py                      # Request/response schemas
    dependencies.py                 # FastAPI dependencies
    
  /config/
    settings.py                     # Environment configuration
    constants.py                    # Application constants
    
  /utils/
    storage.py                      # Supabase Storage operations
    validators.py                   # Input validation utilities
    formatters.py                   # Data formatting helpers
    
  /research/
    name_intelligence.txt           # Cached name patterns
    logo_intelligence.txt           # Cached logo patterns
    color_intelligence.txt          # Cached color patterns
    tagline_intelligence.txt        # Cached tagline patterns

Core Components
1. AI Manager (core/ai_manager.py)
Responsibilities:

Centralize all AI API calls
Handle OpenRouter integration (Claude, GPT, Gemini)
Manage image generation APIs (Flux, Ideogram, etc.)
Implement parallel generation for speed
Track API usage and costs

Key Methods:
pythonasync def generate_text(prompt: str, model: str, temperature: float) -> str
async def generate_parallel(prompts: List[Tuple[str, str]]) -> Dict[str, str]
async def generate_image(description: str, model: str) -> bytes
Design Pattern: Singleton - one instance shared across services

2. Research Loader (core/research_loader.py)
Responsibilities:

Load research documents for each component
Process with Gemini to extract patterns
Cache synthesized intelligence
Provide patterns to generation services

Key Methods:
pythondef get_patterns(component: str) -> str
async def analyze_and_cache(file_path: str, component: str) -> str
def is_cached(component: str) -> bool
Caching Strategy:

File-based cache with 7-day TTL
Lazy loading (load only when needed)
Shared across all service instances

Intelligence Files:

name_intelligence.txt - Patterns for brandable names
logo_intelligence.txt - Visual design principles
color_intelligence.txt - Color psychology & industry norms
tagline_intelligence.txt - Copywriting frameworks


3. Failover Manager (core/failover_manager.py)
Responsibilities:

Manage multiple image generation APIs
Automatic failover when API fails
Track success/failure rates
Cost optimization (prefer cheaper APIs first)

API Priority:

Flux (primary)
Ideogram (backup)
Stability AI (backup)
DALL-E (last resort)

Key Methods:
pythonasync def generate_with_failover(prompt: str) -> bytes
def record_success(api_name: str)
def record_failure(api_name: str)

Service Layer
Name Service (services/name_service.py)
Purpose: Generate brandable business names
Input:

description: str (required)
industry: str (optional)
style: str (optional)

Process:

Load name generation patterns
Construct prompt with patterns + user input
Call AI (Claude or GPT)
Parse and validate output
Return 10 unique names

Output:
json{
  "names": [
    {"name": "FlowAI", "reasoning": "...", "score": 8.5},
    ...
  ],
  "generation_id": "uuid"
}

Domain Service (services/domain_service.py)
Purpose: Check domain availability and pricing
Input:

domains: List[str] (required)
user_id: str (for tracking)

Process:

Parallel DNS checks for all domains
API checks (WhoisXML or WhoAPI) for validation
Marketplace scraping for pricing (optional)
Return availability + purchase links

Output:
json{
  "results": [
    {
      "domain": "flowai.com",
      "available": true,
      "price": "$12.99",
      "registrar_link": "https://...",
      "checked_at": "2025-10-03T..."
    },
    ...
  ]
}
Integration: Existing domain hunter code refactored into this service

Logo Service (services/logo_service.py)
Purpose: Generate logo concepts
Input:

description: str (required)
name: str (required - validated by LLM)
style: str (optional)
existing_colors: List[str] (optional)

Process:

Validate name exists (LLM check)
Load logo design patterns
Generate 3 logo descriptions with AI
Convert descriptions to images (Flux/failover)
Upload to Supabase Storage (PNG, JPG, SVG)
Save to database
Return URLs

Output:
json{
  "logos": [
    {
      "id": "uuid",
      "urls": {
        "png": "https://...",
        "jpg": "https://...",
        "svg": "https://..."
      },
      "description": "Minimalist geometric...",
      "style": "modern"
    },
    ...
  ],
  "generation_id": "uuid"
}
Regeneration: Accepts feedback parameter to improve specific aspects

Color Service (services/color_service.py)
Purpose: Generate color palettes
Input:

description: str (required)
name: str (optional)
logo_reference: str (optional URL to existing logo)
industry: str (optional)

Process:

Load color psychology patterns
Generate 3-5 palette options with AI
Ensure accessibility (WCAG contrast ratios)
Save to database
Return hex codes + RGB values

Output:
json{
  "palettes": [
    {
      "id": "uuid",
      "name": "Trust & Tech",
      "colors": [
        {"hex": "#2D5BFF", "rgb": "45,91,255", "role": "primary"},
        {"hex": "#FFFFFF", "rgb": "255,255,255", "role": "background"},
        ...
      ],
      "reasoning": "Blue conveys trust for fintech..."
    },
    ...
  ]
}

Tagline Service (services/tagline_service.py)
Purpose: Generate tagline variations
Input:

description: str (required)
name: str (required)
tone: str (optional) - professional, playful, bold, etc.

Process:

Load copywriting frameworks
Generate 5 variations with AI
Ensure diversity in tone and length
Save to database
Return taglines with reasoning

Output:
json{
  "taglines": [
    {
      "text": "Your AI productivity companion",
      "tone": "friendly",
      "length": "short",
      "reasoning": "Clear value proposition..."
    },
    ...
  ]
}

Database Schema
Tables
users (managed by Supabase Auth)
sqlid              uuid PRIMARY KEY
email           text UNIQUE NOT NULL
google_id       text UNIQUE
created_at      timestamp DEFAULT now()
projects
sqlid              uuid PRIMARY KEY DEFAULT gen_random_uuid()
user_id         uuid REFERENCES users(id) ON DELETE CASCADE
name            text
description     text NOT NULL
status          text DEFAULT 'draft'  -- draft, completed
created_at      timestamp DEFAULT now()
updated_at      timestamp DEFAULT now()
generations
sqlid              uuid PRIMARY KEY DEFAULT gen_random_uuid()
project_id      uuid REFERENCES projects(id) ON DELETE CASCADE
user_id         uuid REFERENCES users(id) ON DELETE CASCADE
type            text NOT NULL  -- name, logo, color, tagline, domain
input_data      jsonb NOT NULL
output_data     jsonb NOT NULL
ai_model_used   text
cost            decimal(10,4)
created_at      timestamp DEFAULT now()
assets
sqlid                  uuid PRIMARY KEY DEFAULT gen_random_uuid()
generation_id       uuid REFERENCES generations(id) ON DELETE CASCADE
user_id             uuid REFERENCES users(id) ON DELETE CASCADE
type                text NOT NULL  -- image, pdf, svg
format              text NOT NULL  -- png, jpg, svg
storage_path        text NOT NULL
public_url          text NOT NULL
file_size_bytes     integer
copyright_user_id   uuid REFERENCES users(id)
created_at          timestamp DEFAULT now()
usage_tracking
sqlid                  uuid PRIMARY KEY DEFAULT gen_random_uuid()
user_id             uuid REFERENCES users(id) ON DELETE CASCADE
generation_count    integer DEFAULT 0
period_start        timestamp DEFAULT now()
last_reset_at       timestamp DEFAULT now()
Indexes:
sqlCREATE INDEX idx_projects_user_id ON projects(user_id);
CREATE INDEX idx_generations_project_id ON generations(project_id);
CREATE INDEX idx_generations_user_id ON generations(user_id);
CREATE INDEX idx_assets_generation_id ON assets(generation_id);
CREATE INDEX idx_usage_tracking_user_id ON usage_tracking(user_id);

API Endpoints
Authentication
All endpoints require JWT token in Authorization header (except health check)
Authorization: Bearer <supabase_jwt_token>
Endpoints
POST /api/generate/names
jsonRequest:
{
  "description": "AI productivity tool for developers...",
  "industry": "SaaS",
  "style": "modern"
}

Response:
{
  "names": [...],
  "generation_id": "uuid",
  "cost": 0.01
}
POST /api/check/domains
jsonRequest:
{
  "domains": ["flowai.com", "flowai.io"]
}

Response:
{
  "results": [
    {
      "domain": "flowai.com",
      "available": false,
      "status": "registered"
    },
    {
      "domain": "flowai.io",
      "available": true,
      "price": "$39.99",
      "registrar_link": "https://..."
    }
  ]
}
POST /api/generate/logos
jsonRequest:
{
  "description": "AI productivity tool...",
  "name": "FlowAI",
  "style": "minimalist"
}

Response:
{
  "logos": [
    {
      "id": "uuid",
      "urls": {
        "png": "https://storage.supabase.co/...",
        "jpg": "https://...",
        "svg": "https://..."
      },
      "description": "...",
      "style": "minimalist"
    }
  ],
  "generation_id": "uuid"
}
POST /api/generate/colors
jsonRequest:
{
  "description": "AI productivity tool...",
  "name": "FlowAI",
  "logo_reference": "https://..."  // optional
}

Response:
{
  "palettes": [
    {
      "id": "uuid",
      "name": "Tech Trust",
      "colors": [...]
    }
  ]
}
POST /api/generate/taglines
jsonRequest:
{
  "description": "AI productivity tool...",
  "name": "FlowAI",
  "tone": "professional"
}

Response:
{
  "taglines": [
    {
      "text": "AI that flows with your work",
      "tone": "friendly",
      "reasoning": "..."
    }
  ]
}
POST /api/regenerate/{component}
jsonRequest:
{
  "original_generation_id": "uuid",
  "feedback": "Make it more modern and less corporate"
}

Response:
{
  // Same format as original generation
}
GET /api/user/history
jsonResponse:
{
  "projects": [
    {
      "id": "uuid",
      "name": "My AI Startup",
      "created_at": "...",
      "generations": [
        {
          "type": "logo",
          "created_at": "...",
          "assets": [...]
        }
      ]
    }
  ]
}
GET /api/user/usage
jsonResponse:
{
  "generation_count": 2,
  "limit": 2,
  "remaining": 0,
  "resets_at": "2025-11-03T..."
}

Middleware
Authentication (middleware/auth.py)
Purpose: Validate Supabase JWT tokens
Process:

Extract token from Authorization header
Verify with Supabase
Extract user_id
Attach to request context
Reject if invalid

Implementation:

FastAPI dependency injection
Caches user data for request duration
Returns 401 for invalid tokens


Rate Limiter (middleware/rate_limiter.py)
Purpose: Enforce usage limits
MVP Limit: 2 generations per user (adjustable)
Process:

Check user's generation count in database
Increment counter on successful generation
Reset monthly or per payment
Return 429 if limit exceeded

Response when limited:
json{
  "error": "rate_limit_exceeded",
  "message": "You've used all 2 generations. Upgrade for more.",
  "current_usage": 2,
  "limit": 2
}

Configuration
Environment Variables (.env)
bash# Supabase
SUPABASE_URL=https://xxx.supabase.co
SUPABASE_KEY=eyJhbGc...
SUPABASE_SERVICE_KEY=eyJhbGc...

# OpenRouter
OPENROUTER_API_KEY=sk-or-v1-...

# Image APIs
FLUX_API_KEY=...
IDEOGRAM_API_KEY=...
STABILITY_API_KEY=...

# Domain Checking
WHOISXML_API_KEY=...
WHOAPI_KEY=...

# Application
APP_ENV=development  # development, production
LOG_LEVEL=INFO
RATE_LIMIT_GENERATIONS=2

# Storage
STORAGE_BUCKET=brand-assets
CDN_URL=https://cdn.yourdomain.com

Deployment Strategy
Backend Deployment (Railway)
Steps:

Create Railway project
Connect GitHub repository
Add Postgres database (or link Supabase)
Configure environment variables
Deploy from main branch

Railway Configuration:
toml[build]
builder = "NIXPACKS"
buildCommand = "pip install -r requirements.txt"

[deploy]
startCommand = "uvicorn main:app --host 0.0.0.0 --port $PORT"
restartPolicyType = "ON_FAILURE"
Cost Estimate: $5-20/month

Frontend Deployment (Vercel)
Steps:

Connect GitHub repository
Configure build settings
Add environment variables (Supabase keys, API URL)
Deploy from main branch

Build Configuration:
json{
  "buildCommand": "npm run build",
  "outputDirectory": "build",
  "framework": "create-react-app"
}
Cost: Free tier sufficient for MVP

Supabase Setup
Steps:

Create Supabase project
Enable Google OAuth in Authentication
Create database tables (run migrations)
Create storage bucket "brand-assets"
Configure RLS policies
Get API keys for frontend/backend

Storage Policies:
sql-- Allow authenticated users to upload
CREATE POLICY "Users can upload assets"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'brand-assets');

-- Allow public read access
CREATE POLICY "Public can read assets"
ON storage.objects FOR SELECT
TO public
USING (bucket_id = 'brand-assets');

Migration & Refactor Plan
Phase 1: Infrastructure Setup (Week 1)
Day 1-2: Supabase

Create project
Set up authentication
Create database tables
Configure storage bucket

Day 3-4: Backend Foundation

Create FastAPI app structure
Implement AI Manager (extract from domain hunter)
Set up Research Loader
Configure environment

Day 5-7: First Service

Implement Logo Service (simplest to test)
Create API endpoint
Test end-to-end with Postman
Deploy to Railway


Phase 2: Core Services (Week 2)
Day 1-2: Name & Domain Services

Extract domain checking logic from existing code
Implement name generation service
Wire up API endpoints

Day 3-4: Color & Tagline Services

Implement color palette generation
Implement tagline generation
Test all services independently

Day 5-7: Integration

Connect all services
Implement rate limiting
Add error handling
Test complete flows


Phase 3: Frontend Integration (Week 3)
Day 1-3: React Components

Update existing domain hunter UI
Add brand generation components
Implement Supabase auth
Connect to backend API

Day 4-5: User Dashboard

Display generation history
Show usage limits
Download functionality

Day 6-7: Polish

Error handling in UI
Loading states
Responsive design
Deploy to Vercel


Phase 4: Testing & Launch (Week 4)
Day 1-3: Testing

End-to-end user flows
Load testing
Security audit
Bug fixes

Day 4-5: Documentation

API documentation
User guide
Setup instructions

Day 6-7: Launch Prep

Analytics setup
Monitoring
Soft launch to friends
Collect feedback


Future Enhancements (Post-MVP)
Immediate (Month 2-3)

Stripe payment integration
Unlimited regenerations for paid users
PDF brand guidelines export
Advanced analytics dashboard
Email notifications

Medium-term (Month 4-6)

Voice mode (conversational generation)
Figma design system export
Website mockup generation
Business card templates
Social media content kit

Long-term (6+ months)

Team collaboration features
White-label for agencies
API for developers
Integration marketplace
AI brand consultant chat


Cost Analysis
Per User (2 Generations)
AI Costs:

Name generation: 1 × Claude = $0.01
Domain checks: 10 × DNS = $0.00
Logo generation: 3 × Flux = $0.15
Color generation: 3 × Claude = $0.01
Tagline generation: 5 × Claude = $0.01

Total per user: ~$0.18 × 2 = $0.36
With 1000 free users: $360/month in AI costs
Infrastructure:

Railway: $20/month
Supabase: Free tier (up to 50k users)
Vercel: Free tier

Total MVP cost: ~$380/month for 1000 users

Success Metrics
Product Metrics

Conversion rate (visitor → sign-up)
Completion rate (started → downloaded package)
Average time to complete
Regeneration frequency

Business Metrics

Monthly active users
User retention (30-day)
Viral coefficient (referrals)
Cost per acquisition

Quality Metrics

User satisfaction score
Component preference (which logos/colors chosen)
Feedback sentiment
Support ticket volume


Risk Mitigation
Technical Risks
API Downtime

Solution: Failover system for image APIs
Monitoring: Health checks every 5 minutes
Fallback: Graceful degradation, queue retries

Cost Overruns

Solution: Strict rate limiting
Monitoring: Real-time cost tracking
Alert: Email when daily cost > threshold

Data Loss

Solution: Supabase automatic backups
Recovery: Point-in-time restore
Testing: Quarterly disaster recovery drills

Business Risks
Low User Engagement

Mitigation: Start with free tier, collect feedback
Pivot: Adjust features based on usage data
Marketing: Launch on Product Hunt, Reddit

Competition

Mitigation: Speed to market, unique positioning
Differentiation: Focus on complete package vs fragments
Community: Build loyal early adopter base


Conclusion
This architecture is:

Modular: Services work independently
Scalable: Horizontal scaling for each service
Future-proof: Database + auth ready for commercial launch
Maintainable: Clear separation of concerns
Cost-effective: ~$0.36 per user, sustainable for free MVP

The refactor strategy prioritizes:

Quick wins (extract reusable components)
Incremental migration (don't break existing code)
Testing at each phase (validate before proceeding)
Learning through building (understand patterns)

You're ready to start building.
</document>